-- =====================================================
-- RecoverRight Database Schema
-- Complete SQL setup for Supabase PostgreSQL database
-- =====================================================

-- =====================================================
-- 1. CREATE ENUMS
-- =====================================================

-- User role enum (create only if it doesn't exist)
DO $$ BEGIN
    CREATE TYPE user_role AS ENUM ('player', 'physician', 'coach');
EXCEPTION
    WHEN duplicate_object THEN null;
END $$;

-- =====================================================
-- 2. CORE USER MANAGEMENT TABLES
-- =====================================================

-- Table: users
-- Description: Stores core user information linked directly to Supabase auth profiles
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email TEXT NOT NULL UNIQUE,
    role user_role NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =====================================================
-- 3. ORGANIZATIONAL STRUCTURE
-- =====================================================

-- Table: teams
-- Description: Defines organizational structure (e.g., MLB Team X)
-- Note: Created before profiles since profiles references teams
CREATE TABLE IF NOT EXISTS teams (
    id SERIAL PRIMARY KEY,
    team_name TEXT NOT NULL UNIQUE,
    organization_level TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Table: profiles
-- Description: Stores extended user profile details, including required signup data (name, age)
CREATE TABLE IF NOT EXISTS profiles (
    user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
    full_name TEXT NOT NULL,
    age INTEGER NOT NULL CHECK (age > 15),
    team_id INTEGER REFERENCES teams(id) ON DELETE SET NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =====================================================
-- 4. PLAYER TRACKING AND REFLECTION DATA
-- =====================================================

-- Table: player_logs
-- Description: Stores each daily recovery reflection submission by a player
-- Note: ai_insight_id foreign key is added after ai_insights table is created (see below)
CREATE TABLE IF NOT EXISTS player_logs (
    id BIGSERIAL PRIMARY KEY,
    player_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    reflection_text TEXT NOT NULL,
    pain_location_tags TEXT[] DEFAULT '{}',
    pain_severity_level INTEGER CHECK (pain_severity_level >= 1 AND pain_severity_level <= 10),
    energy_level INTEGER NOT NULL CHECK (energy_level >= 1 AND energy_level <= 10),
    soreness_level INTEGER NOT NULL CHECK (soreness_level >= 1 AND soreness_level <= 10),
    submitted_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    health_score DECIMAL(4,2) CHECK (health_score >= 0.00 AND health_score <= 100.00),
    ai_insight_id BIGINT
);

-- Table: ai_insights
-- Description: Stores the structured recovery plan generated by Gemini AI based on the player log
CREATE TABLE IF NOT EXISTS ai_insights (
    id BIGSERIAL PRIMARY KEY,
    log_id BIGINT NOT NULL UNIQUE REFERENCES player_logs(id) ON DELETE CASCADE,
    mobility_plan JSONB NOT NULL,
    nutrition_rest_plan JSONB NOT NULL,
    generated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Add foreign key constraint from player_logs to ai_insights (after both tables exist)
-- Only add if it doesn't already exist
DO $$ 
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'fk_player_logs_ai_insight_id'
    ) THEN
        ALTER TABLE player_logs
            ADD CONSTRAINT fk_player_logs_ai_insight_id
            FOREIGN KEY (ai_insight_id) REFERENCES ai_insights(id) ON DELETE SET NULL;
    END IF;
END $$;

-- =====================================================
-- 5. COMMUNICATION (PHYSICIAN MESSAGING)
-- =====================================================

-- Table: conversations
-- Description: Manages threads between a Physician and a Player
CREATE TABLE IF NOT EXISTS conversations (
    id BIGSERIAL PRIMARY KEY,
    player_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    physician_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    last_message_at TIMESTAMPTZ,
    CONSTRAINT conversation_unique UNIQUE (player_id, physician_id)
);

-- Table: messages
-- Description: Stores the real-time chat history
CREATE TABLE IF NOT EXISTS messages (
    id BIGSERIAL PRIMARY KEY,
    conversation_id BIGINT NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
    sender_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    content TEXT NOT NULL,
    sent_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    read_by_recipient BOOLEAN NOT NULL DEFAULT FALSE
);

-- Table: message_attachments
-- Description: Stores metadata for files attached by physicians (e.g., tailored workout PDFs)
CREATE TABLE IF NOT EXISTS message_attachments (
    id BIGSERIAL PRIMARY KEY,
    message_id BIGINT NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
    file_path TEXT NOT NULL,
    file_type TEXT NOT NULL,
    uploaded_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =====================================================
-- 6. INDEXES FOR PERFORMANCE
-- =====================================================

-- Users table indexes
CREATE INDEX IF NOT EXISTS idx_users_role ON users(role);
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);

-- Profiles table indexes
CREATE INDEX IF NOT EXISTS idx_profiles_team_id ON profiles(team_id);

-- Player logs indexes (critical for dashboard performance)
CREATE INDEX IF NOT EXISTS idx_player_logs_player_id ON player_logs(player_id);
CREATE INDEX IF NOT EXISTS idx_player_logs_submitted_at ON player_logs(submitted_at DESC);
CREATE INDEX IF NOT EXISTS idx_player_logs_health_score ON player_logs(health_score);
CREATE INDEX IF NOT EXISTS idx_player_logs_ai_insight_id ON player_logs(ai_insight_id);

-- AI insights indexes
CREATE INDEX IF NOT EXISTS idx_ai_insights_log_id ON ai_insights(log_id);
CREATE INDEX IF NOT EXISTS idx_ai_insights_generated_at ON ai_insights(generated_at DESC);

-- Conversations indexes
CREATE INDEX IF NOT EXISTS idx_conversations_player_id ON conversations(player_id);
CREATE INDEX IF NOT EXISTS idx_conversations_physician_id ON conversations(physician_id);
CREATE INDEX IF NOT EXISTS idx_conversations_last_message_at ON conversations(last_message_at DESC NULLS LAST);

-- Messages indexes (critical for real-time messaging)
CREATE INDEX IF NOT EXISTS idx_messages_conversation_id ON messages(conversation_id);
CREATE INDEX IF NOT EXISTS idx_messages_sender_id ON messages(sender_id);
CREATE INDEX IF NOT EXISTS idx_messages_sent_at ON messages(sent_at DESC);
CREATE INDEX IF NOT EXISTS idx_messages_read_by_recipient ON messages(read_by_recipient) WHERE read_by_recipient = FALSE;

-- Message attachments indexes
CREATE INDEX IF NOT EXISTS idx_message_attachments_message_id ON message_attachments(message_id);

-- =====================================================
-- 7. FUNCTIONS AND TRIGGERS
-- =====================================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically update updated_at in profiles
DROP TRIGGER IF EXISTS update_profiles_updated_at ON profiles;
CREATE TRIGGER update_profiles_updated_at
    BEFORE UPDATE ON profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Function to update last_message_at in conversations
CREATE OR REPLACE FUNCTION update_conversation_last_message()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE conversations
    SET last_message_at = NEW.sent_at
    WHERE id = NEW.conversation_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to automatically update last_message_at when a message is sent
DROP TRIGGER IF EXISTS update_conversation_timestamp ON messages;
CREATE TRIGGER update_conversation_timestamp
    AFTER INSERT ON messages
    FOR EACH ROW
    EXECUTE FUNCTION update_conversation_last_message();

-- =====================================================
-- 8. ROW LEVEL SECURITY (RLS) POLICIES
-- =====================================================

-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE teams ENABLE ROW LEVEL SECURITY;
ALTER TABLE player_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_insights ENABLE ROW LEVEL SECURITY;
ALTER TABLE conversations ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;
ALTER TABLE message_attachments ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- RLS POLICIES: users
-- =====================================================

-- Users can insert their own user record during signup
DROP POLICY IF EXISTS "Users can insert own user record" ON users;
CREATE POLICY "Users can insert own user record"
    ON users FOR INSERT
    WITH CHECK (auth.uid() = id);

-- Users can view their own user record
DROP POLICY IF EXISTS "Users can view own user record" ON users;
CREATE POLICY "Users can view own user record"
    ON users FOR SELECT
    USING (auth.uid() = id);

-- Users can view all users (for dashboards - players, physicians, coaches)
DROP POLICY IF EXISTS "Users can view all users" ON users;
CREATE POLICY "Users can view all users"
    ON users FOR SELECT
    USING (auth.role() = 'authenticated');

-- =====================================================
-- RLS POLICIES: profiles
-- =====================================================

-- Users can insert their own profile during signup
DROP POLICY IF EXISTS "Users can insert own profile" ON profiles;
CREATE POLICY "Users can insert own profile"
    ON profiles FOR INSERT
    WITH CHECK (auth.uid() = user_id);

-- Users can view their own profile
DROP POLICY IF EXISTS "Users can view own profile" ON profiles;
CREATE POLICY "Users can view own profile"
    ON profiles FOR SELECT
    USING (auth.uid() = user_id);

-- Users can update their own profile
DROP POLICY IF EXISTS "Users can update own profile" ON profiles;
CREATE POLICY "Users can update own profile"
    ON profiles FOR UPDATE
    USING (auth.uid() = user_id);

-- All authenticated users can view all profiles (for dashboards)
DROP POLICY IF EXISTS "Authenticated users can view all profiles" ON profiles;
CREATE POLICY "Authenticated users can view all profiles"
    ON profiles FOR SELECT
    USING (auth.role() = 'authenticated');

-- =====================================================
-- RLS POLICIES: teams
-- =====================================================

-- All authenticated users can view teams
DROP POLICY IF EXISTS "Authenticated users can view teams" ON teams;
CREATE POLICY "Authenticated users can view teams"
    ON teams FOR SELECT
    USING (auth.role() = 'authenticated');

-- =====================================================
-- RLS POLICIES: player_logs
-- =====================================================

-- Players can view their own logs
DROP POLICY IF EXISTS "Players can view own logs" ON player_logs;
CREATE POLICY "Players can view own logs"
    ON player_logs FOR SELECT
    USING (
        auth.uid() = player_id OR
        EXISTS (
            SELECT 1 FROM users
            WHERE users.id = auth.uid()
            AND users.role IN ('physician', 'coach')
        )
    );

-- Players can insert their own logs
DROP POLICY IF EXISTS "Players can insert own logs" ON player_logs;
CREATE POLICY "Players can insert own logs"
    ON player_logs FOR INSERT
    WITH CHECK (
        auth.uid() = player_id AND
        EXISTS (
            SELECT 1 FROM users
            WHERE users.id = auth.uid()
            AND users.role = 'player'
        )
    );

-- Players can update their own logs (if needed)
DROP POLICY IF EXISTS "Players can update own logs" ON player_logs;
CREATE POLICY "Players can update own logs"
    ON player_logs FOR UPDATE
    USING (auth.uid() = player_id)
    WITH CHECK (auth.uid() = player_id);

-- =====================================================
-- RLS POLICIES: ai_insights
-- =====================================================

-- Users can view AI insights for logs they have access to
DROP POLICY IF EXISTS "Users can view accessible AI insights" ON ai_insights;
CREATE POLICY "Users can view accessible AI insights"
    ON ai_insights FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM player_logs
            WHERE player_logs.id = ai_insights.log_id
            AND (
                player_logs.player_id = auth.uid() OR
                EXISTS (
                    SELECT 1 FROM users
                    WHERE users.id = auth.uid()
                    AND users.role IN ('physician', 'coach')
                )
            )
        )
    );

-- System can insert AI insights (via service role or API)
-- Note: This may need to be adjusted based on your API implementation
DROP POLICY IF EXISTS "Service can insert AI insights" ON ai_insights;
CREATE POLICY "Service can insert AI insights"
    ON ai_insights FOR INSERT
    WITH CHECK (true);

-- =====================================================
-- RLS POLICIES: conversations
-- =====================================================

-- Users can view conversations they are part of
DROP POLICY IF EXISTS "Users can view own conversations" ON conversations;
CREATE POLICY "Users can view own conversations"
    ON conversations FOR SELECT
    USING (
        player_id = auth.uid() OR
        physician_id = auth.uid()
    );

-- Physicians can create conversations with players
DROP POLICY IF EXISTS "Physicians can create conversations" ON conversations;
CREATE POLICY "Physicians can create conversations"
    ON conversations FOR INSERT
    WITH CHECK (
        physician_id = auth.uid() AND
        EXISTS (
            SELECT 1 FROM users
            WHERE users.id = auth.uid()
            AND users.role = 'physician'
        )
    );

-- =====================================================
-- RLS POLICIES: messages
-- =====================================================

-- Users can view messages in conversations they are part of
DROP POLICY IF EXISTS "Users can view own conversation messages" ON messages;
CREATE POLICY "Users can view own conversation messages"
    ON messages FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM conversations
            WHERE conversations.id = messages.conversation_id
            AND (
                conversations.player_id = auth.uid() OR
                conversations.physician_id = auth.uid()
            )
        )
    );

-- Users can send messages in conversations they are part of
DROP POLICY IF EXISTS "Users can send messages in own conversations" ON messages;
CREATE POLICY "Users can send messages in own conversations"
    ON messages FOR INSERT
    WITH CHECK (
        sender_id = auth.uid() AND
        EXISTS (
            SELECT 1 FROM conversations
            WHERE conversations.id = messages.conversation_id
            AND (
                conversations.player_id = auth.uid() OR
                conversations.physician_id = auth.uid()
            )
        )
    );

-- Users can update read status of messages sent to them
DROP POLICY IF EXISTS "Users can update own message read status" ON messages;
CREATE POLICY "Users can update own message read status"
    ON messages FOR UPDATE
    USING (
        EXISTS (
            SELECT 1 FROM conversations
            WHERE conversations.id = messages.conversation_id
            AND (
                (conversations.player_id = auth.uid() AND conversations.physician_id = messages.sender_id) OR
                (conversations.physician_id = auth.uid() AND conversations.player_id = messages.sender_id)
            )
        )
    )
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM conversations
            WHERE conversations.id = messages.conversation_id
            AND (
                (conversations.player_id = auth.uid() AND conversations.physician_id = messages.sender_id) OR
                (conversations.physician_id = auth.uid() AND conversations.player_id = messages.sender_id)
            )
        )
    );

-- =====================================================
-- RLS POLICIES: message_attachments
-- =====================================================

-- Users can view attachments for messages they have access to
DROP POLICY IF EXISTS "Users can view accessible attachments" ON message_attachments;
CREATE POLICY "Users can view accessible attachments"
    ON message_attachments FOR SELECT
    USING (
        EXISTS (
            SELECT 1 FROM messages
            JOIN conversations ON conversations.id = messages.conversation_id
            WHERE messages.id = message_attachments.message_id
            AND (
                conversations.player_id = auth.uid() OR
                conversations.physician_id = auth.uid()
            )
        )
    );

-- Users can insert attachments for messages they sent
DROP POLICY IF EXISTS "Users can insert attachments for own messages" ON message_attachments;
CREATE POLICY "Users can insert attachments for own messages"
    ON message_attachments FOR INSERT
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM messages
            WHERE messages.id = message_attachments.message_id
            AND messages.sender_id = auth.uid()
        )
    );

-- =====================================================
-- 9. HELPER VIEWS (Optional but useful)
-- =====================================================

-- View: player_logs_with_insights
-- Description: Joins player_logs with ai_insights for easier querying
CREATE OR REPLACE VIEW player_logs_with_insights AS
SELECT 
    pl.*,
    ai.mobility_plan,
    ai.nutrition_rest_plan,
    ai.generated_at as ai_generated_at
FROM player_logs pl
LEFT JOIN ai_insights ai ON pl.ai_insight_id = ai.id;

-- View: conversation_messages_with_attachments
-- Description: Joins messages with attachments for easier querying
CREATE OR REPLACE VIEW conversation_messages_with_attachments AS
SELECT 
    m.*,
    COALESCE(
        json_agg(
            json_build_object(
                'id', ma.id,
                'file_path', ma.file_path,
                'file_type', ma.file_type,
                'uploaded_at', ma.uploaded_at
            )
        ) FILTER (WHERE ma.id IS NOT NULL),
        '[]'::json
    ) as attachments
FROM messages m
LEFT JOIN message_attachments ma ON m.id = ma.message_id
GROUP BY m.id;

-- =====================================================
-- 10. COMMENTS FOR DOCUMENTATION
-- =====================================================

COMMENT ON TABLE users IS 'Core user information linked to Supabase auth';
COMMENT ON TABLE profiles IS 'Extended user profile details (name, age, team)';
COMMENT ON TABLE teams IS 'Organizational structure (MLB teams, etc.)';
COMMENT ON TABLE player_logs IS 'Daily recovery reflection submissions by players';
COMMENT ON TABLE ai_insights IS 'Structured recovery plans generated by Gemini AI';
COMMENT ON TABLE conversations IS 'Message threads between physicians and players';
COMMENT ON TABLE messages IS 'Individual messages in conversations';
COMMENT ON TABLE message_attachments IS 'File attachments for messages';

COMMENT ON COLUMN player_logs.health_score IS 'Calculated score (0-100) used for Coach health indicator';
COMMENT ON COLUMN player_logs.pain_location_tags IS 'Array of pain location tags (e.g., ["shoulder", "hamstring"])';
COMMENT ON COLUMN ai_insights.mobility_plan IS 'JSONB structure: {exercises: [{name, duration, intensity, equipment?}]}';
COMMENT ON COLUMN ai_insights.nutrition_rest_plan IS 'JSONB structure: {hydration, nutrition: [], rest}';

-- =====================================================
-- END OF SCHEMA
-- =====================================================

